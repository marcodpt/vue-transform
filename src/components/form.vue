<script type="text/babel">
  import T from 'libt'
  import lib from '../lib.js'
  import tmxIcon from './icon.vue'
  import tmxItem from './item.vue'

  module.exports = {
    mixins: [lib],
    components: {
      'tmx-icon': tmxIcon,
      'tmx-item': tmxItem
    },
    props: {
      model: {
        type: Object,
        default: function () {
          return {}
        }
      },
      fields: {
        type: Array
      },
      submit: {
        type: Function
      },
      onChange: {
        type: Function
      },
      onClose: {
        type: Function
      },
      size: {
        type: String,
        default: 'md',
        validator: lib.methods.isSize
      },
      icon: {
        type: String,
        default: '',
        validator: lib.methods.isIcon
      },
      label: {
        type: String,
        default: ''
      },
      alert: {
        type: String,
        default: 'danger',
        validator: lib.methods.isAlert
      },
      text: {
        type: String,
        default: ''
      },
      buttons: {
        type: Array,
        default: function () {
          return []
        }
      }
    },
    data: function () {
      return {
        backup: T.copy(this.model),
        compact: !this.submit && !this.onChange,
        fields2: []
      }
    },
    mounted: function () {
      this.load()
    },
    watch: {
      model: {
        deep: true,
        handler: function () {
          if (typeof this.onChange === 'function') {
            var diff = false
            Object.keys(this.model).forEach(key => {
              if (this.model[key] != this.$data.backup[key]) {
                diff = true
              }
            })
            if (diff && this.validateModel()) {
              this.$data.backup = T.copy(this.model)
              this.onChange(this.model)
            }
          }
        }
      },
      fields: function () {
        this.load()
      }
    },
    methods: {
      run: function () {
        if (typeof this.submit === 'function' && this.validateModel()) {
          this.submit(this.model)
          if (this.onClose) {
            this.onClose()
          }
        }
      },
      hasFields: function () {
        return (this.fields && this.fields.length) || Object.keys(this.model).length
      },
      load: function () {
        if (!(this.fields instanceof Array)) {
          T.sync(this.$data.fields2, this.setFields(this.model))
        } else {
          T.sync(this.$data.fields2, this.fields)
        }
        this.$data.fields2.forEach(field => {
          this.$set(this.model, field.id, T.parse(field.format)(this.model[field.id]))
        })
      },
      getClass: function () {
        if (['success', 'info', 'warning', 'danger'].indexOf(this.alert) !== -1) {
          return 'alert alert-' + this.alert
        } else {
          return 'well'
        }
      },
      validateModel: function () {
        var valid = true

        this.fields.forEach((field, i) => {
          field.format = field.format || 'string'
          this.$set(this.model, field.id, T.parse(field.format)(this.model[field.id]))
          this.$set(this.fields[i], 'error', '')
          var error = false
          var empty = this.model[field.id] == null
          var label = field.label || field.placeholder || field.id
          if (field.static) {
            return
          }
          if (field.format === 'json' && this.model[field.id]) {
            try {
              var x = JSON.parse(this.model[field.id])
            } catch (err) {
              this.$set(this.fields[i], 'error', `${label} ${err.toString()}`)
              valid = false
              error = true
            }
          }
          if (!error && !empty && field.validate instanceof Array) {
            field.validate.forEach(v => {
              if (!error && !T.evaluate(v.assert)(this.model)) {
                this.$set(this.fields[i], 'error', `${label} ${v.error}`)
                valid = false
                error = true
              }
            })
          }
          if (!error && field.watchlen && (String(this.model[field.id]).length < field.watchlen || empty)) {
            valid = false
          }
        })

        return valid
      }
    }
  }
</script>

<template>
  <div class="thumbnail">
    <div v-if="onClose || label || icon" class="modal-header">
      <button v-if="onClose" type="button" class="close" @click="onClose">
        <tmx-icon name="times"/>
      </button>
      <h4 v-if="label || icon" style="text-align:center" class="modal-title">
        <tmx-icon :name="icon" /> {{label}}
      </h4>
    </div>
    <div v-if="hasFields() || text" class="modal-body">
      <div style="clear: both;"></div>
      <form class="form-horizontal" @submit.prevent="submit">
        <tmx-item
          v-for="(field, index) in fields2"
          :key="index"
          :model="model"
          v-bind="field"
          :static="field.static || compact"
          :compact="compact"
          :size="field.size || size"
        >
        </tmx-item>
      </form>
      <div style="clear: both;"></div>
      <div 
        v-if="text"
        :class="getClass()" 
        style="white-space:pre-line;"
      ><big>{{text}}</big></div>
      <div style="clear: both;"></div>
    </div>
    <div v-if="buttons.length" class="modal-footer">
      <button
        v-for="b in buttons"
        :class="[
          'btn',
          'btn-' + b.type,
          b.block ? 'btn-block' : '',
          b.size ? 'btn-' + b.size : 'btn-' + size
        ]"
        @click="b.click ? b.click(model) : run()"
      >
        <tmx-icon :name="b.icon"/>
        {{b.label}}
      </button>
    </div>
  </div>
</template>
